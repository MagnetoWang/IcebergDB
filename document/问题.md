

## 问题

### 什么是malloc

### 什么是allocators

### 什么是jemalloc

### 什么是/dev/null 和 

- 解答：https://www.cnblogs.com/lishihai/p/7986565.html
-  或称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF。
- 如果我们不想看到错误输出呢？我们可以禁止标准错误:   cat $badname 2>/dev/null

### 什么是静态库和动态库

- .a 和 .so的区别：https://www.cnblogs.com/52php/p/5681755.html
- bin,include和lib的区别：https://bbs.csdn.net/topics/391963573
  - include放头文件
  - lib放库文件比如静态库动态库
  - bin放可执行文件

### 内存分配原理

- malloc：https://blog.csdn.net/junlon2006/article/details/77854898

### 什么是mmap 和 munmap函数

- 介绍：https://blog.csdn.net/tengyft/article/details/45846409
- mmap函数用于申请一段内存空间。我们可以将这段内存作为进程间通信的共享内存，也可以将文件直接映射到其中。munmap函数则释放由mmap创建的这段内存空间。

### string string.h cstring头文件区别

- 解释：https://www.cnblogs.com/McKean/p/6083861.html

### 编译器默认函数的作用

- 解释说明：https://www.cnblogs.com/liushui-sky/p/5802910.html

### 构造函数和赋值函数的区别

- 它们都是拷贝函数
- https://www.cnblogs.com/nigang/p/3613452.html

### 两个字符串如何比较

```c++
inline int Slice::compare(const Slice& b) const {
  const size_t min_len = (size_ < b.size_) ? size_ : b.size_;
  int r = memcmp(data_, b.data_, min_len);
  if (r == 0) {
    if (size_ < b.size_) r = -1;
    else if (size_ > b.size_) r = +1;
  }
  return r;
}
```

### 编写比较器

```c++
struct Comparator {
  int operator()(const Key& a, const Key& b) const {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return +1;
    } else {
      return 0;
    }
  }
};
```



### 为什么要初始化列表

- 解释：http://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html

### 为什么要使用句柄handle

- 解释：http://www.cnblogs.com/marchtea/archive/2011/12/04/2275534.html

### 如何禁止自定义的类被外部复制

- 将构造函数写进private
- 将赋值函数写进private
- 这样外部函数无法调用
- 但是因为有friend类型可能会调用
- 那么给构造和赋值一个空实现
- 这样间接实现了禁止类互相复制的情况

### 什么是内存屏障

- 参考资料：https://blog.csdn.net/caoshangpa/article/details/78853919
- Memory Barriers: a Hardware View for Software Hackers论文：http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.06.07c.pdf
- 论文部分定义解释：https://blog.csdn.net/m0_37561834/article/details/78457078

### 大数输出类型问题

- 参考资料：https://baike.baidu.com/item/stdint.h/2439217

- int64_t数的输出：%lld ;

  uint64_t数的输出：%llu ;

  uint64_t数十六[进制](https://baike.baidu.com/item/%E8%BF%9B%E5%88%B6)输出：%llx ;

  uint64_t数八进制输出：%llo ;



### .cc .cpp .C .cp区别

- 说明：https://blog.csdn.net/ledaosi/article/details/41079121
- win一般用cpp
- linux一般用cc
- c就是c语言文件

### struct 和 class 区别

- 简单对比：https://blog.csdn.net/xdrt81y/article/details/17143801
- 默认的访问控制，struct继承是public，class是private

### 实现写进头文件或者写进源文件的优缺点

- 全写进头文件
- 好处
  - 方便调用
  - 减少链接的一系列问题
- 坏处
  - 编译时间过长
  - 不方便开源，暴露实现代码

### 什么是nullptr

- c++11中的空指针
- 参考资料：https://www.cnblogs.com/porter/p/3611718.html

### 什么是deadbeaf

- rnd_(0xdeadbeef)

### 什么是intptr_t

- https://blog.csdn.net/macchan/article/details/38701811
- **intptr_t是为了跨平台，其长度总是所在平台的位数，所以用来存放地址**

### 什么是左值和右值

- 参考资料：https://blog.csdn.net/hyman_yx/article/details/52044632
- 在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）
- int a = b+c
- a就是左值
- b+c计算出来的值就是右值
- 所以 & (b+c) 是编译失败的，因为没有变量名，根本找不到它的地址

### 什么是左值引用、右值引用

- https://stackoverflow.com/questions/4986673/c11-rvalues-and-move-semantics-confusion-return-statement
- 左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。
- 右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。
- 左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。
- 常量左值引用

```
int &a = 2;       # 左值引用绑定到右值，编译失败

int b = 2;        # 非常量左值
const int &c = b; # 常量左值引用绑定到非常量左值，编译通过
const int d = 2;  # 常量左值
const int &e = c; # 常量左值引用绑定到常量左值，编译通过
const int &b =2;  # 常量左值引用绑定到右值，编程通过
```

- 右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值

```
int a;
int &&r1 = c;             # 编译失败
int &&r2 = std::move(a);  # 编译通过
```

### 字面量常量和string之间的区别

- 字面量常量 不是 string类型
- 所以如果字面量常量赋值到string 必须是const
- https://stackoverflow.com/questions/27869719/since-a-string-literal-is-considered-an-lvalue-why-must-the-binding-lvalue-refe
- 字面量常量类型：char const[N]
- 正确使用字面量方式：std::string& s = std::string("Abcdefg");

### 使用new创建动态结构体

- 参考资料：https://blog.csdn.net/qq_41200424/article/details/80710314
- leveldb里面用到了这个技术，newNode函数

### 什么是noexcept

- https://www.xuebuyuan.com/2069091.html
- noexcept的功能相当于上面的throw()，表示函数不会抛出异常。如果noexcept修饰的函数抛出了异常，编译器可以选择直接调用std::terminate()终止程序运行。noexcept比throw()效率高一些

### 什么是constexpr

- http://www.cnblogs.com/wodehao0808/p/3623590.html
- 其语义是“常量表达式”，也就是在编译期可求值的表达式。最基础的常量表达式就是字面值或全局变量/函数的地址或sizeof等关键字返回的结果，而其它常量表达式都是由基础表达式通过各种确定的运算得到的。constexpr值可用于enum、switch、数组长度等场合。
- constexpr所修饰的变量一定是编译期可求值的，所修饰的函数在其所有参数都是constexpr时，一定会返回constexpr。

### 什么是crc32c

- 参考资料
  - https://baike.baidu.com/item/CRC32/7460858
  - 
- CRC校验实用程序库 在[数据存储](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/9827490)和[数据通讯](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%80%9A%E8%AE%AF/1006573)领域，为了保证数据的正确，就不得不采用检错的手段。在诸多检错手段中，CRC是最著名的一种。CRC的全称是[循环冗余校验](https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C/3219009)。
- x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11+ x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1

### 为什么函数后面添加0

- https://blog.csdn.net/toyijiu/article/details/82591347
- 这是声明纯虚函数
- 就是告诉编译器，纯虚函数没有函数体，没有函数功能不能调用

### 大小端转换问题

- https://blog.csdn.net/tenghui0425/article/details/23924291
- 测试机器采用大小端：https://blog.csdn.net/archyli/article/details/78568915

## bug问题

### Undefined symbols for architecture x86_64

- 解决方案
  - 用file(GLOB SRC_FILES ${PROJECT_SOURCE_DIR}/src/*.cc)命令，然后再添加依赖进去
  - 进一步发现
  - 在使用gflags库和add_executable命令的时候，没有把flag.cc文件添加进去所以编译失败
  - 也就是说
  - 不需要file()这个命令
- 再一次出现这个问题
  - 编译时缺少需要的依赖文件
  - 实际情况
  - 有arena.h,arena.cpp和base_test.cpp
  - 无法直接编译base_test.cpp
  - 问题出在，base_test无法真正的调用到arena.cpp里面的函数
  - 解决方案一
    - 将arena.cpp内容复制到arena.h。只有一个头文件引用即可
  - 解决方案二
    - 将arena.cpp编程成静态库
    - add_library arena.cpp
    - 然后base_test链接库即可
- 参考资料：https://stackoverflow.com/questions/41453253/googletest-cmake-undefined-symbols-for-architecture-x86-64

### library not found for -lfolly

- 

### .#if, #elif, #else, and #endif

- https://msdn.microsoft.com/en-us/library/ew2hz0yd.aspx?f=255&MSPPError=-2147217396

### ifndef, define 和 endif的作用
- https://www.cnblogs.com/challenger-vip/p/3386819.html

### non-const lvalue reference to type 'unsigned int' cannot bind to a temporary of type 'int'

- const 右值引用问题
- 中间产生临时变量：http://www.cnblogs.com/lailailai/p/4675831.html

### Segmentation fault: 11

- 地址没有初始化的问题

### std::string& from an rvalue of type ‘std::basic_string from an rvalue of type ‘std::basic_string< char>

- 字面量和string 不是同一类型要区别对待

## 技术区别

### FBString 代替 std::string

- 放弃使用FBString
- https://github.com/facebook/folly/blob/master/folly/docs/FBString.md
- 设计说明：http://www.cnblogs.com/promise6522/archive/2012/06/05/2535530.html

### jemalloc

### 使用标准库的random

- 文档：http://www.cplusplus.com/reference/random/?kw=random

### leveldb 的 原子指针

- 详细介绍：https://blog.csdn.net/caoshangpa/article/details/78852255

### leveldb的arena内存分配

- 详细介绍：http://www.cnblogs.com/xey-csu/p/5060552.html

### 不同计算机不同的字节大小

- 参考资料：https://blog.csdn.net/macchan/article/details/38701811

```
arch  Size:  char  short  int  long  ptr long-long  u8 u16 u32 u64 
i386         1     2      4    4     4   8          1  2   4   8  
alpha        1     2      4    8     8   8          1  2   4   8  
armv4l       1     2      4    4     4   8          1  2   4   8  
ia64         1     2      4    8     8   8          1  2   4   8  
m68k         1     2      4    4     4   8          1  2   4   8  
mips         1     2      4    4     4   8          1  2   4   8  
ppc          1     2      4    4     4   8          1  2   4   8  
sparc        1     2      4    4     4   8          1  2   4   8  
sparc64      1     2      4    4     4   8          1  2   4   8  
x86_64       1     2      4    8     8   8          1  2   4   8  
```

### 跳表的细节

- 创建节点的时候内存分配策略：节点+多个层的指针的大小
- 跳表内部compare_：默认比较key
- FindGreaterOrEqual：额外传递的prev参数似乎没有什么用

### levledb中state的复制问题

- state固定格式：前3位代表后面message长度，所以在代码的实现上为了不出现错误我们不能用常规的memcpy复制里面的字节

```
个人最初解法
const char* Status::CopyState(const char* state) {
    char* result = new char[strlen(state)];
    memcpy(result, state, strlen(state));
    return result;
}

因为strlen是读到 \0 才结束。但是我们不能保证字符串结尾一定有\0 所以上面的代码有缺陷

最佳解法
const char* Status::CopyState(const char* state) {
    uint32_t size;
    memcpy(&size, state, sizeof(size));
    char* result = new char[size + 5];
    memcpy(result, state, size + 5);
    return result;
}
```

### leveldb中logging写入问题

- 资料
  - http://brg-liuwei.github.io/tech/2014/10/24/leveldb-5.html
  - https://blog.csdn.net/u012658346/article/details/45311691
- AddRecord
  - 检查是否能写入到当前block，否则要重新新建block
  - 检查完成才调用EmitPhysicalRecord
- EmitPhysicalRecord
  - 直接写入文件中
- 

### 引用计数实现

- 代码参考：https://www.cnblogs.com/George1994/p/6041398.html

### leveldb中编码问题

- http://www.cnblogs.com/YuNanlong/p/9424802.html
- 

## 细节问题

### cmake相关

- 每个执行文件要想成功运行，必须源文件要写全！！！

## 参考资料

- http://brg-liuwei.github.io/

