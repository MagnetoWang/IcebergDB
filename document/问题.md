[TOC]



## 问题

### 什么是malloc

### 什么是allocators

### 什么是jemalloc

### 什么是/dev/null 和 

- 解答：https://www.cnblogs.com/lishihai/p/7986565.html
- 或称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF。
- 如果我们不想看到错误输出呢？我们可以禁止标准错误:   cat $badname 2>/dev/null
- 或者说不想看到输出信息也可以用这个 2>/dev/null

### 什么是静态库和动态库

- .a 和 .so的区别：https://www.cnblogs.com/52php/p/5681755.html
- bin,include和lib的区别：https://bbs.csdn.net/topics/391963573
  - include放头文件
  - lib放库文件比如静态库动态库
  - bin放可执行文件

### 内存分配原理

- malloc：https://blog.csdn.net/junlon2006/article/details/77854898

### 什么是mmap 和 munmap函数

- 介绍：https://blog.csdn.net/tengyft/article/details/45846409
- mmap函数用于申请一段内存空间。我们可以将这段内存作为进程间通信的共享内存，也可以将文件直接映射到其中。munmap函数则释放由mmap创建的这段内存空间。

### 什么是gnu-getopt

- 文档：https://baike.baidu.com/item/getopt/4705064
- 函数使用：https://www.gnu.org/software/libc/manual/html_node/Getopt.html
- 解析参数的函数

### 什么是.h.in 文件

- https://stackoverflow.com/questions/42719401/what-is-the-cmakedefine-preprocessor-directive
- These files are usually the input for [autoconf](http://www.gnu.org/software/autoconf/manual/autoconf.html) which will generate final .h files.

### string string.h cstring头文件区别

- 解释：https://www.cnblogs.com/McKean/p/6083861.html

### 编译器默认函数的作用

- 解释说明：https://www.cnblogs.com/liushui-sky/p/5802910.html

### 构造函数和赋值函数的区别

- 它们都是拷贝函数
- https://www.cnblogs.com/nigang/p/3613452.html

### 两个字符串如何比较

```c++
inline int Slice::compare(const Slice& b) const {
  const size_t min_len = (size_ < b.size_) ? size_ : b.size_;
  int r = memcmp(data_, b.data_, min_len);
  if (r == 0) {
    if (size_ < b.size_) r = -1;
    else if (size_ > b.size_) r = +1;
  }
  return r;
}
```

### 编写比较器

```c++
struct Comparator {
  int operator()(const Key& a, const Key& b) const {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return +1;
    } else {
      return 0;
    }
  }
};
```



### 为什么要初始化列表

- 解释：http://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html

### 为什么要使用句柄handle

- 解释：http://www.cnblogs.com/marchtea/archive/2011/12/04/2275534.html

### 如何禁止自定义的类被外部复制

- 将构造函数写进private
- 将赋值函数写进private
- 这样外部函数无法调用
- 但是因为有friend类型可能会调用
- 那么给构造和赋值一个空实现
- 这样间接实现了禁止类互相复制的情况

### 什么是内存屏障

- 参考资料：https://blog.csdn.net/caoshangpa/article/details/78853919
- Memory Barriers: a Hardware View for Software Hackers论文：http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.06.07c.pdf
- 论文部分定义解释：https://blog.csdn.net/m0_37561834/article/details/78457078

### 大数输出类型问题

- 参考资料：https://baike.baidu.com/item/stdint.h/2439217

- int64_t数的输出：%lld ;

  uint64_t数的输出：%llu ;

  uint64_t数十六[进制](https://baike.baidu.com/item/%E8%BF%9B%E5%88%B6)输出：%llx ;

  uint64_t数八进制输出：%llo ;



### .cc .cpp .C .cp区别

- 说明：https://blog.csdn.net/ledaosi/article/details/41079121
- win一般用cpp
- linux一般用cc
- c就是c语言文件

### struct 和 class 区别

- 简单对比：https://blog.csdn.net/xdrt81y/article/details/17143801
- 默认的访问控制，struct继承是public，class是private

### bashrc与profile的区别

- http://www.cnblogs.com/hongzg1982/articles/2101792.html
- bashrc针对个人用户设置
- bashprofile针对全局变量
- ~/.bash_profile
- ~/.bashrc

### 实现写进头文件或者写进源文件的优缺点

- 全写进头文件
- 好处
  - 方便调用
  - 减少链接的一系列问题
- 坏处
  - 编译时间过长
  - 不方便开源，暴露实现代码

### 什么是nullptr

- c++11中的空指针
- 参考资料：https://www.cnblogs.com/porter/p/3611718.html

### 什么是deadbeaf

- rnd_(0xdeadbeef)

### 什么是intptr_t

- https://blog.csdn.net/macchan/article/details/38701811
- **intptr_t是为了跨平台，其长度总是所在平台的位数，所以用来存放地址**

### 什么是左值和右值

- 参考资料：https://blog.csdn.net/hyman_yx/article/details/52044632
- 在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）
- int a = b+c
- a就是左值
- b+c计算出来的值就是右值
- 所以 & (b+c) 是编译失败的，因为没有变量名，根本找不到它的地址

### 什么是左值引用、右值引用

- https://stackoverflow.com/questions/4986673/c11-rvalues-and-move-semantics-confusion-return-statement
- 左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。
- 右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。
- 左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。
- 常量左值引用

```
int &a = 2;       # 左值引用绑定到右值，编译失败

int b = 2;        # 非常量左值
const int &c = b; # 常量左值引用绑定到非常量左值，编译通过
const int d = 2;  # 常量左值
const int &e = c; # 常量左值引用绑定到常量左值，编译通过
const int &b =2;  # 常量左值引用绑定到右值，编程通过
```

- 右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值

```
int a;
int &&r1 = c;             # 编译失败
int &&r2 = std::move(a);  # 编译通过
```

### 字面量常量和string之间的区别

- 字面量常量 不是 string类型
- 所以如果字面量常量赋值到string 必须是const
- https://stackoverflow.com/questions/27869719/since-a-string-literal-is-considered-an-lvalue-why-must-the-binding-lvalue-refe
- 字面量常量类型：char const[N]
- 正确使用字面量方式：std::string& s = std::string("Abcdefg");

### 使用new创建动态结构体

- 参考资料：https://blog.csdn.net/qq_41200424/article/details/80710314
- leveldb里面用到了这个技术，newNode函数

### 什么是noexcept

- https://www.xuebuyuan.com/2069091.html
- noexcept的功能相当于上面的throw()，表示函数不会抛出异常。如果noexcept修饰的函数抛出了异常，编译器可以选择直接调用std::terminate()终止程序运行。noexcept比throw()效率高一些

### 什么是npos

- http://www.cplusplus.com/reference/string/string/npos/
- static const size_t npos = -1;
- As a return value, it is usually used to indicate no matches.
- This constant is defined with a value of -1, which because size_t is an unsigned integral type, it is the largest possible representable value for this type.

### 什么是constexpr

- http://www.cnblogs.com/wodehao0808/p/3623590.html
- 其语义是“常量表达式”，也就是在编译期可求值的表达式。最基础的常量表达式就是字面值或全局变量/函数的地址或sizeof等关键字返回的结果，而其它常量表达式都是由基础表达式通过各种确定的运算得到的。constexpr值可用于enum、switch、数组长度等场合。
- constexpr所修饰的变量一定是编译期可求值的，所修饰的函数在其所有参数都是constexpr时，一定会返回constexpr。

### 什么是crc32c

- 参考资料
  - https://baike.baidu.com/item/CRC32/7460858
  - 
- CRC校验实用程序库 在[数据存储](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/9827490)和[数据通讯](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%80%9A%E8%AE%AF/1006573)领域，为了保证数据的正确，就不得不采用检错的手段。在诸多检错手段中，CRC是最著名的一种。CRC的全称是[循环冗余校验](https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C/3219009)。
- x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11+ x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1

### 为什么函数后面添加0

- https://blog.csdn.net/toyijiu/article/details/82591347
- 这是声明纯虚函数
- 就是告诉编译器，纯虚函数没有函数体，没有函数功能不能调用

### 大小端转换问题

- https://blog.csdn.net/tenghui0425/article/details/23924291
- 测试机器采用大小端：https://blog.csdn.net/archyli/article/details/78568915

### 什么是ssize_t

- https://blog.csdn.net/lplp90908/article/details/50405899
- https://baike.baidu.com/item/size_t/8101179
- ssize_t是有符号整型
- size_t 就是无符号型的ssize_t

### 什么是LSM-tree

- https://en.wikipedia.org/wiki/Log-structured_merge-tree

### 什么是End of thread safety annotations 

- http://www.cnblogs.com/muhe221/articles/5101726.html
- 如果一个对象被mutex监视，在不锁住这个对象的时候，编译期间会发出警告，以此提醒编程者

### 什么是LLVM

- 

### kafka怎样写入日志

### kafka怎样删除和更新日志

### kafka怎样备份

### kafka怎样分区

### kafka怎样通信

### unistd 和 fcnt头文件区别

- http://blog.sina.com.cn/s/blog_67eb1f2f0100m0sa.html
- fcntl.h定义了很多宏和open,fcntl函数原型
- unistd.h定义了更多的函数原型

### 析构函数继承的问题

- 加virtual会出现调用找不到虚表
- 析构函数一定要实现，default

## bug问题

### Undefined symbols for architecture x86_64

- 解决方案
  - 用file(GLOB SRC_FILES ${PROJECT_SOURCE_DIR}/src/*.cc)命令，然后再添加依赖进去
  - 进一步发现
  - 在使用gflags库和add_executable命令的时候，没有把flag.cc文件添加进去所以编译失败
  - 也就是说
  - 不需要file()这个命令
- 再一次出现这个问题
  - 编译时缺少需要的依赖文件
  - 实际情况
  - 有arena.h,arena.cpp和base_test.cpp
  - 无法直接编译base_test.cpp
  - 问题出在，base_test无法真正的调用到arena.cpp里面的函数
  - 解决方案一
    - 将arena.cpp内容复制到arena.h。只有一个头文件引用即可
  - 解决方案二
    - 将arena.cpp编程成静态库
    - add_library arena.cpp
    - 然后base_test链接库即可
- 参考资料：https://stackoverflow.com/questions/41453253/googletest-cmake-undefined-symbols-for-architecture-x86-64

### library not found for -lfolly

- 

### .#if, #elif, #else, and #endif

- https://msdn.microsoft.com/en-us/library/ew2hz0yd.aspx?f=255&MSPPError=-2147217396

### ifndef, define 和 endif的作用
- https://www.cnblogs.com/challenger-vip/p/3386819.html

### non-const lvalue reference to type 'unsigned int' cannot bind to a temporary of type 'int'

- const 右值引用问题
- 中间产生临时变量：http://www.cnblogs.com/lailailai/p/4675831.html

### Segmentation fault: 11

- 地址没有初始化的问题

### std::string& from an rvalue of type ‘std::basic_string from an rvalue of type ‘std::basic_string< char>

- 字面量和string 不是同一类型要区别对待

### control reaches end of non-void function [-Wreturn-type]

- https://stackoverflow.com/questions/2440337/warning-control-reaches-end-of-non-void-function-iphone
- 少了return 语句

### a missing vtable usually means the first non-inline virtual member function has no definition

- https://stackoverflow.com/questions/31861803/a-missing-vtable-usually-means-the-first-non-inline-virtual-member-function-has
- 有虚拟函数没有实现
- 或者析构和构造函数遗漏，并没有实现

### has internal linkage but is not defined [-Wundefined-internal]

- https://stackoverflow.com/questions/51070909/c-function-has-internal-linkage-but-is-not-defined
- 头文件定义了static函数，cpp文件又实现了static函数，这里有冲突
- 去掉static的关键词

### duplicate symbol __ZNK4ibdb4base6Status8ToStringEv in:

- 问题
  - 可能重名
  - 可能重复实现
- 参考解决方案
  - https://blog.csdn.net/fww330666557/article/details/50773915
- 简单粗暴方案
  - cpp实现全部放到头文件中

### protobuf出现undefined reference 

- 版本问题
- 3.6有很多问题不适配一些库
- 一般改用2.5即可

### 'OSAtomicCompareAndSwap64Barrier' is deprecated: first deprecated in macOS 10.12 - Use std::atomic_compare_exchange_strong() from < atomic > instead [-Wdeprecated-declarations]

- protobuf版本问题
- protobuf可以考虑3.0版本

### extra qualification on member 'Table'

- 代码少了一个字母

### config_brpc: --headers=HDRPATHS --libs=LIBPATHS must be specified

- 执行brpc的配置脚本出现的问题
- 后面是更改脚本，因为脚本里面有一个--headers ) HDRS_IN="\$ ( \${REALPATH} \$2 )"; shift 2 ;
- 这个REALPATH是null，所以导致无法识别参数路径
- 把这个REALPATH 参数删除即可！

### error: variable has incomplete type 'butil::FilePath'

- 在使用brpc的工具库代码出现的问题
- 原因是没有添加include的文件，导致无法找到FilePath这个类！

### sed: 1: "config_brpc.sh": command c expects \ followed by text

- mac系统的问题！！！

### ERROR: flag 'v' was defined more than once (in files '/tmp/glog-20181112-13696-5e12fz/glog-0.3.5/src/vlog_is_on.cc' and 'src/butil/logging.cc').

- 初步认为这是版本冲突问题
- https://github.com/apache/incubator-brpc/issues/609

### error: This file was generated by a newer version of protoc which is

- 版本路径问题！！

### error: incompatible with your Protocol Buffer headers. Please update

- 版本路径问题！！

### no matching member function for call to 'insert'

- 使用map出现的问题
- 插入的数据对象不对！！！
- 必须理解清楚里面的对象形式，尤其是map里面还嵌入一个map对象时，必须也是insert一个map对象而不是其他什么值

```
std::map<std::string, std::map<uint64_t, uint32_t> > offset_pos_map_;
// 错误写法！！！
offset_pos_map_.insert(std::make_pair(table_manifest_.current_log_file().log_name(), std::make_pair(current_offset_, current_pos)));
```

###  qualified reference to 'Table' is a constructor name rather than a type in this context

- 语法不规范.table多打了一个冒号

### error: call to implicitly-deleted copy constructor of

- 参考资料
  - https://stackoverflow.com/questions/19559503/call-to-implicitly-deleted-copy-constructor-in-llvm
  - https://stackoverflow.com/questions/45385437/call-to-implicitly-deleted-copy-constructor
- 下面的问题出在skiplist这个类不允许复制
- 这个时候部分函数会有歧义
- 部分函数可能会触发到复制构造函数，导致无法使用这些函数，然后就会报错
- 仔细看下面的错误函数
- FindEqual(key)->value;
- 这里的value在我的代码中是个跳表对象，如果把它返回出去，那么就会出现对象复制的情况
- 因为继承了Noncopyable，所以禁止复制！
- 这里有bug。把传出对象改成指针即可！

- ```
  In file included from /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/test/storage/table_test.cpp:1:
  In file included from /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/storage/table.h:13:
  In file included from /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/storage/segment.h:6:
  /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/base/skiplist.h:352:12: error: call to implicitly-deleted copy constructor of
        'ibdb::base::SkipList<ibdb::base::Slice, unsigned long long, ibdb::storage::SliceComparator>'
      return FindEqual(key)->value;
             ^~~~~~~~~~~~~~~~~~~~~
  /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/storage/segment.h:97:40: note: in instantiation of member function 'ibdb::base::SkipList<unsigned long long,
        ibdb::base::SkipList<ibdb::base::Slice, unsigned long long, ibdb::storage::SliceComparator>, ibdb::storage::TimeStampComparator>::GetValue' requested here
          return segment_->GetValue(key).GetValue(timestamp).Contains(value);
                                         ^
  /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/base/skiplist.h:14:18: note: copy constructor of 'SkipList<ibdb::base::Slice, unsigned long long,
        ibdb::storage::SliceComparator>' is implicitly deleted because base class 'ibdb::base::Noncopyable' has a deleted copy constructor
  class SkipList : Noncopyable {
                   ^
  /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/base/noncopyable.h:8:5: note: 'Noncopyable' has been explicitly marked deleted here
      Noncopyable(const Noncopyable&) = delete;
  ```


### cannot access private member declared in class

- 不小心调用了私有成员函数，尤其是operator操作函数之类的
- 比如=,()之类的

### error: no matching constructor for initialization of 'ibdb::base::SkipList<unsigned long long, ibdb::base::SkipList<ibdb::base::Slice, unsigned long long, ibdb::storage::SliceComparator>,ibdb::storage::TimeStampComparator>' Node(uint8_t h) : height(h), key(NULL), value(NULL) {}

-  参考资料：https://stackoverflow.com/questions/33089047/c-no-matching-constructor-for-initialization-candidate-constructor-not-viab

- ```
  In file included from /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/test/storage/table_test.cpp:1:
  In file included from /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/storage/table.h:13:
  In file included from /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/storage/segment.h:6:
  /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/base/skiplist.h:82:45: error: no matching constructor for initialization of 'ibdb::base::SkipList<unsigned
        long long, ibdb::base::SkipList<ibdb::base::Slice, unsigned long long, ibdb::storage::SliceComparator>, ibdb::storage::TimeStampComparator>'
      Node(uint8_t h) : height(h), key(NULL), value(NULL) {}
                                              ^     ~~~~
  /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/base/skiplist.h:137:21: note: in instantiation of member function 'ibdb::base::SkipList<ibdb::base::Slice,
        ibdb::base::SkipList<unsigned long long, ibdb::base::SkipList<ibdb::base::Slice, unsigned long long, ibdb::storage::SliceComparator>,
        ibdb::storage::TimeStampComparator>, ibdb::storage::SliceComparator>::Node::Node' requested here
      return new (mem)Node(height);
                      ^
  /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/base/skiplist.h:287:15: note: in instantiation of member function 'ibdb::base::SkipList<ibdb::base::Slice,
        ibdb::base::SkipList<unsigned long long, ibdb::base::SkipList<ibdb::base::Slice, unsigned long long, ibdb::storage::SliceComparator>,
        ibdb::storage::TimeStampComparator>, ibdb::storage::SliceComparator>::NewNode' requested here
          head_(NewNode(kMaxHeight)),
                ^
  /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/storage/segment.h:72:16: note: in instantiation of member function 'ibdb::base::SkipList<ibdb::base::Slice,
        ibdb::base::SkipList<unsigned long long, ibdb::base::SkipList<ibdb::base::Slice, unsigned long long, ibdb::storage::SliceComparator>,
        ibdb::storage::TimeStampComparator>, ibdb::storage::SliceComparator>::SkipList' requested here
      segment_ = Entries(feature_comp, &arena);
                 ^
  /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/base/skiplist.h:14:7: note: candidate constructor (the implicit copy constructor) not viable: no known
        conversion from 'long' to 'const ibdb::base::SkipList<unsigned long long, ibdb::base::SkipList<ibdb::base::Slice, unsigned long long,
        ibdb::storage::SliceComparator>, ibdb::storage::TimeStampComparator>' for 1st argument
  class SkipList : Noncopyable {
        ^
  /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/base/skiplist.h:18:5: note: candidate constructor not viable: requires 2 arguments, but 1 was provided
      SkipList(Comparator cmp, Arena* arena);
  ```

  ### 'operator()' is a private member of 'ibdb::storage::SliceComparator'

  - 比较一般都声明struct，用class会默认为private属性，就没办法使用！！！

###  error: no matching function for call to object of type 'const ibdb::storage::TimeStampComparator' return (n != nullptr) && (compare_(n->key, key) < 0);

- 

###  error: cannot initialize a member subobject of type 'const unsigned long long' with an 

### rvalue of type 'nullptr_t' Node(uint8_t h) : height(h), key(nullptr), value(nullptr) {}

- 

###  error: no matching function for call to object of type 'const ibdb::storage::TimeStampComparator'  return (compare_(a, b) == 0);

- 

```
In file included from /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/test/storage/table_test.cpp:1:
In file included from /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/storage/table.h:13:
In file included from /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/storage/segment.h:6:
/Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/base/skiplist.h:60:17: error: no matching function for call to object of type
      'const ibdb::storage::TimeStampComparator'
        return (compare_(a, b) == 0);
                ^~~~~~~~
/Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/base/skiplist.h:321:25: note: in instantiation of member function 'ibdb::base::SkipList<unsigned long long,
      ibdb::base::SkipList<ibdb::base::Slice, ibdb::storage::SegmentOffset *, ibdb::storage::SliceComparator> *, ibdb::storage::TimeStampComparator>::Equal'
      requested here
    if (x != nullptr && Equal(key, x->key)) {
                        ^
/Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/storage/segment.h:103:46: note: in instantiation of member function 'ibdb::base::SkipList<unsigned long long,
      ibdb::base::SkipList<ibdb::base::Slice, ibdb::storage::SegmentOffset *, ibdb::storage::SliceComparator> *, ibdb::storage::TimeStampComparator>::Contains'
      requested here
        return (*(segment_->GetValue(key)))->Contains(timestamp);
                                             ^
/Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/storage/segment.h:27:9: note: candidate function not viable: 'this' argument has type
      'const ibdb::storage::TimeStampComparator', but method is not marked const
    int operator()(const uint64_t a, const uint64_t b) {
```

###  candidate function not viable: no known conversion from  'const ibdb::storage::SegmentTimeStamp' to 'const int' for 1st argument

- 

- ```
    /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/base/skiplist.h:60:17: error: no matching function for call to object of type
        'const ibdb::storage::TimeStampComparator'
          return (compare_(a, b) == 0);
                  ^~~~~~~~
      /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/base/skiplist.h:321:25: note: in instantiation of member function
        'ibdb::base::SkipList<ibdb::storage::SegmentTimeStamp, ibdb::base::SkipList<ibdb::base::Slice, ibdb::storage::SegmentOffset *, ibdb::storage::SliceComparator>
        *, ibdb::storage::TimeStampComparator>::Equal' requested here
      if (x != nullptr && Equal(key, x->key)) {                      ^
      /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/storage/segment.h:108:46: note: in instantiation of member function
        'ibdb::base::SkipList<ibdb::storage::SegmentTimeStamp, ibdb::base::SkipList<ibdb::base::Slice, ibdb::storage::SegmentOffset *, ibdb::storage::SliceComparator>
        *, ibdb::storage::TimeStampComparator>::Contains' requested here
          return (*(segment_->GetValue(key)))->Contains(timestamp);
                                               ^
      /Users/magnetowang/Documents/GitHub/IcebergDB/ibdb/src/storage/segment.h:27:9: note: candidate function not viable: no known conversion from
        'const ibdb::storage::SegmentTimeStamp' to 'const int' for 1st argument
      int operator()(const SegmentTimeStamp& a, const SegmentTimeStamp& b) const {
    ```

###  warning: 'OSAtomicCompareAndSwap64Barrier' is deprecated: first deprecated in macOS 10.12 - Use std::atomic_compare_exchange_strong() from <atomic> instead [-Wdeprecated-declarations]

- warning实在太多，一个文件出现11次warning。总共有3个文件依赖，出现33次。严重影响找error,定位error的效率了

- ```
  echo sh generate-code.sh 2>/dev/null
  probubuf生成的代码，全部投进空设备中
  ```

### error: binding value of type 'const ibdb::base::Slice' to reference to type 'ibdb::base::Slice' drops 'const' qualifier Key& key() {return key_;}

- 

### candidate constructor (the implicit move constructor) not viable

- 

### error: cannot assign to non-static data member 'tail_' with const-qualified type

```
error: cannot assign to non-static data member 'tail_' with const-qualified type
      'ibdb::base::SkipList<ibdb::storage::SegmentTimeStamp, ibdb::base::SkipList<ibdb::base::Slice, ibdb::storage::SegmentOffset *, ibdb::storage::SliceComparator>
      *, ibdb::storage::TimeStampComparator>::Node *const'
            tail_ = NewNode(kMaxHeight);
```



## 技术区别

### FBString 代替 std::string

- 放弃使用FBString
- https://github.com/facebook/folly/blob/master/folly/docs/FBString.md
- 设计说明：http://www.cnblogs.com/promise6522/archive/2012/06/05/2535530.html

### jemalloc

### 使用标准库的random

- 文档：http://www.cplusplus.com/reference/random/?kw=random

### leveldb 的 原子指针

- 详细介绍：https://blog.csdn.net/caoshangpa/article/details/78852255

### leveldb的arena内存分配

- 详细介绍：http://www.cnblogs.com/xey-csu/p/5060552.html

### 不同计算机不同的字节大小

- 参考资料：https://blog.csdn.net/macchan/article/details/38701811

  ```
  arch  Size:  char  short  int  long  ptr long-long  u8 u16 u32 u64 
  i386         1     2      4    4     4   8          1  2   4   8  
  alpha        1     2      4    8     8   8          1  2   4   8  
  armv4l       1     2      4    4     4   8          1  2   4   8  
  ia64         1     2      4    8     8   8          1  2   4   8  
  m68k         1     2      4    4     4   8          1  2   4   8  
  mips         1     2      4    4     4   8          1  2   4   8  
  ppc          1     2      4    4     4   8          1  2   4   8  
  sparc        1     2      4    4     4   8          1  2   4   8  
  sparc64      1     2      4    4     4   8          1  2   4   8  
  x86_64       1     2      4    8     8   8          1  2   4   8  
  ```
```

### 跳表的细节

- 创建节点的时候内存分配策略：节点+多个层的指针的大小
- 跳表内部compare_：默认比较key
- FindGreaterOrEqual：额外传递的prev参数似乎没有什么用

### levledb中state的复制问题

- state固定格式：前3位代表后面message长度，所以在代码的实现上为了不出现错误我们不能用常规的memcpy复制里面的字节

```
个人最初解法
const char* Status::CopyState(const char* state) {
​    char* result = new char[strlen(state)];
​    memcpy(result, state, strlen(state));
​    return result;
}

因为strlen是读到 \0 才结束。但是我们不能保证字符串结尾一定有\0 所以上面的代码有缺陷

最佳解法
const char* Status::CopyState(const char* state) {
​    uint32_t size;
​    memcpy(&size, state, sizeof(size));
​    char* result = new char[size + 5];
​    memcpy(result, state, size + 5);
​    return result;
}
```

### leveldb中logging写入和读出问题

- 资料
  - http://brg-liuwei.github.io/tech/2014/10/24/leveldb-5.html
  - https://blog.csdn.net/u012658346/article/details/45311691
- AddRecord
  - 检查是否能写入到当前block，否则要重新新建block
  - 检查完成才调用EmitPhysicalRecord
- EmitPhysicalRecord
  - 直接写入文件中
- 日志结构
  - https://zhuanlan.zhihu.com/p/35134533
- 读日志
  - https://blog.csdn.net/weixin_36145588/article/details/76423338

### 引用计数实现

- 代码参考：https://www.cnblogs.com/George1994/p/6041398.html

### leveldb中编码问题

- http://www.cnblogs.com/YuNanlong/p/9424802.html

## 细节问题

### cmake相关

- 每个执行文件要想成功运行，必须源文件要写全！！！

## 参考资料

- http://brg-liuwei.github.io/


```